# 单例模式
## 应用场景
- 资源管理器：例如数据库连接池、线程池等资源管理器，通过单例模式确保全局只有一个资源管理器实例，方便资源的统一管理和分配。
- 配置信息类：用于存储系统的配置信息，如日志配置、数据库配置等。通过单例模式可以确保配置信息在系统中全局唯一且方便访问。
- 日志记录器：单例模式可以确保系统中只有一个日志记录器实例，方便统一管理系统的日志记录。
- 状态管理器：用于管理系统的状态信息，例如用户登录状态、应用程序状态等。单例模式可以确保状态信息的一致性和全局访问。
- 计数器

## 实现
### 枚举
- 线程安全：JVM 在加载枚举类型时会通过类加载器保证线程安全，确保只有一个实例被创建，并且在多线程环境下不会出现竞争条件
- 可以避免通过反射破坏枚举单例：由于枚举类型的实例是在类加载时被创建的，且枚举类的构造函数默认是私有的，因此无法通过反射机制来调用私有构造函数来创建新的实例
```java
public enum Singleton {
    INSTANCE;
    public void doSomething(String str) {
        System.out.println(str);
    }
}
```
调用：
```java
Singleton.INSTANCE.doSomething("Hello");
```


### 静态内部类
私有构造方法 + 静态内部类
- 支持延时加载：外部类被加载时，并不会创建静态内部类的示例对象。当调用 `getInstance()` 方法时才创建实例对象 `INSTNCE`
- 线程安全：由 JVM 保证

```java
public class Singleton {

    private Singleton() {}

    public Singleton getInstance() {
        return SingletonInner.INSTANCE;
    }

    private static class SingletonInner {
        private final static Singleton INSTANCE = new Singleton();
    }
}
```

### 双重校验锁
- 支持延时加载
- 线程安全
```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            } 
        }
        return uniqueInstance;
    }
}
```