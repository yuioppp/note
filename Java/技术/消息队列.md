## 使用场景
解耦：一个系统或模块，调用了多个系统或模块，互相之间调用比较复杂，维护困难，可以使用 MQ 进行系统的解耦  
异步：如果一个系统处理用户请求时要调用别的系统的接口，耗时较长，可以让该系统发送消息到消息队列中减少用户等待时间  
削峰：高峰期并发请求数过多可能导致系统崩溃，可以将请求写入 MQ，系统再慢慢拉取请求进行处理  

## 优缺点
### 优点
在特殊场景下可以解耦、异步、削峰  
### 缺点  
- 系统可用性降低：系统引入的外部依赖越多，越容易崩溃  
- 系统复杂性提高：怎么保证消息没有被重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？......  
- 一致性问题

## 常用的 MQ 对比
### 特性  
- ActiveMQ：单机吞吐量万级，比 RocketMQ、Kafka 低一个数量级  
- RabbitMQ：万级  
- RocketMQ：万级，支持高吞吐  
- Kafka：10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景  
### topic数量对吞吐量的影响
- ActiveMQ：  
- RabbitMQ：   
- RocketMQ：topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic  
- Kafka：topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源  
### 时效性
- ActiveMQ：ms 级  
- RabbitMQ：微秒级，这是 RabbitMQ 的一大特点，延迟最低  
- RocketMQ：ms 级  
- Kafka：ms 级以内  
### 可用性
- ActiveMQ：高，基于主从架构实现高可用  
- RabbitMQ：高，基于主从架构实现高可用  
- RocketMQ：非常高，分布式架构  
- Kafka：非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用
### 消息可靠性
- ActiveMQ：有较低的概率丢失数据   
- RabbitMQ：基本不丢   
- RocketMQ：经过参数优化配置，可以做到 0 丢失  
- Kafka：经过参数优化配置，可以做到 0 丢失  
### 功能支持
- ActiveMQ：MQ 领域的功能极其完备  
- RabbitMQ：基于 erlang 开发，并发能力很强，性能极好，延时很低  
- RocketMQ：MQ 功能较为完善，还是分布式的，扩展性好  
- Kafka：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算和日志采集被大规模使用
 
中小型公司：RabbitMQ，大型公司：RocketMQ，大数据领域的实时计算和日志采集场景：Kafka

## 保证 MQ 的高可用
### RabbitMQ
#### 单机模式
普通集群模式：在多台机器上启动多个 RabbitMQ 实例，创建的 queue 放在一个 RabbitMQ 实例上，但每个实例都同步 queue 的元数据  
镜像集群模式：元数据和 queue 里的消息存在于多个实例上  
保证消息不被重复消费 / 消息消费的幂等性  
结合业务  

## 消息的可靠性传输
### RabbitMQ
#### 消息丢失的情况：
1. 消息在传入的过程中丢失：开启 confirm 模式
2. RabbitMQ 崩溃，数据丢失：开启 RabbitMQ 的持久化
3. 消费者没处理就挂掉，RabbitMQ 以为消息已经被处理：关闭 RabbitMQ 的自动 ack 机制
#### 消息的顺序性
拆分多个 queue，一个消费者一个 queue  
消费者内部用内存队列排队，分发给底层不同的 worker 处理  
