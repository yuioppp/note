# 理论基础

## 基本概念

### 为什么需要多线程
CPU、内存、I/O 设备的速度有极大差异，为了合理利用 CPU 的高性能，平衡这三者的速度差异：
- CPU 增加了缓存，以均衡与内存的速度差异，导致可见性问题  
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，导致原子性问题  
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用，导致有序性问题


### 并发问题出现的原因
#### 可见性
定义：一个线程对共享变量的修改，另外一个线程能够立刻看到  
#### 原子性
定义：一个操作或者多个操作，要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行
#### 有序性
定义：程序执行的顺序按照代码的先后顺序执行  
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。


### 解决并发问题：JMM（Java内存模型）
Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。
具体来说，这些方法包括：
#### volatile、synchronized、final 三个关键字

#### Happens-Before 规则
- 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作
- 管程锁定原则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作
- volatile 规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作
- 线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作
- 线程加入规则：Thread 对象的结束先行发生于 join() 方法返回
- 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生
- 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始
- 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C


### 线程安全
#### 不可变
不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施  
不可变的类型：
- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但 AtomicInteger 和 AtomicLong 是可变的

#### 绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施  

#### 相对线程安全
需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性  
Java 中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等

#### 线程兼容
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用

#### 线程对立
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码


### 线程安全的实现方法
#### 同步
- synchronized

#### 互斥
互斥/阻塞同步：线程需要进行阻塞和唤醒（悲观锁）
- ReentrantLock

#### 非阻塞同步
- CAS
基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则不断重试，直到成功为止  
乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B  
- AtomicInteger

#### 无同步方案
- 栈封闭
- ThreadLocal
- 可重入代码
