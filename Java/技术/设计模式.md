# 单例模式
## 概念
核心思想是保证一个类只有一个实例，并提供一个全局访问点来访问这个实例
## 应用场景
- 资源管理器：例如数据库连接池、线程池等资源管理器，通过单例模式确保全局只有一个资源管理器实例，方便资源的统一管理和分配。
- 配置信息类：用于存储系统的配置信息，如日志配置、数据库配置等。通过单例模式可以确保配置信息在系统中全局唯一且方便访问。
- 日志记录器：单例模式可以确保系统中只有一个日志记录器实例，方便统一管理系统的日志记录。
- 状态管理器：用于管理系统的状态信息，例如用户登录状态、应用程序状态等。单例模式可以确保状态信息的一致性和全局访问。
- 计数器
## 实现
### 枚举
- 线程安全：JVM 在加载枚举类型时会通过类加载器保证线程安全，确保只有一个实例被创建，并且在多线程环境下不会出现竞争条件
- 可以避免通过反射破坏枚举单例：由于枚举类型的实例是在类加载时被创建的，且枚举类的构造函数默认是私有的，因此无法通过反射机制来调用私有构造函数来创建新的实例
```java
public enum Singleton {
    INSTANCE;
    public void doSomething(String str) {
        System.out.println(str);
    }
}
```
调用：
```java
Singleton.INSTANCE.doSomething("Hello");
```


### 静态内部类
私有构造方法 + 静态内部类
- 支持延时加载：外部类被加载时，并不会创建静态内部类的示例对象。当调用 `getInstance()` 方法时才创建实例对象 `INSTNCE`
- 线程安全：由 JVM 保证

```java
public class Singleton {

    private Singleton() {}

    public Singleton getInstance() {
        return SingletonInner.INSTANCE;
    }

    private static class SingletonInner {
        private final static Singleton INSTANCE = new Singleton();
    }
}
```

### 双重校验锁
- 支持延时加载
- 线程安全
```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            } 
        }
        return uniqueInstance;
    }
}
```

# 工厂方法模式
## 简单工厂模式
核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面   
简单工厂模式包括三个主要角色，工厂类、抽象产品、具体产品  
简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码
## 工厂方法模式
工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码  
工厂方法模式分为以下几个角色：
- 抽象工厂：一个接口，包含一个抽象的工厂方法（用于创建产品对象）。
- 具体工厂：实现抽象工厂接口，创建具体的产品。
- 抽象产品：定义产品的接口。
- 具体产品：实现抽象产品接口，是工厂创建的对象
## 应用场景
- Spring 框架中的 Bean 工厂：通过配置文件或注解，Spring 可以根据配置信息动态地创建和管理对象
- JDBC 中的 Connection 工厂：在 Java 数据库连接中，DriverManager 使用工厂方法模式来创建数据库连接。不同的数据库驱动（如 MySQL、PostgreSQL 等）都有对应的工厂来创建连接

# 抽象工厂模式
## 概念
在工厂方法模式中，每个具体工厂只负责创建单一的产品，而抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用。e.g.如沙发、茶几、椅子，都具有古典风格的和现代风格的，抽象工厂模式可以将生产现代风格的家具放在一个工厂类中，将生产古典风格的家具放在另一个工厂类中，这样每个工厂类就可以生产一系列的家具。  
## 基本结构
抽象工厂模式包含多个抽象产品接口，多个具体产品类，一个抽象工厂接口和多个具体工厂，每个具体工厂负责创建一组相关的产品。  
- 抽象产品接口 AbstractProduct: 定义产品的接口，可以定义多个抽象产品接口，如沙发、椅子、茶几都是抽象产品。
- 具体产品类 ConcreteProduct: 实现抽象产品接口，产品的具体实现，古典风格和沙发和现代风格的沙发都是具体产品。
- 抽象工厂接口 AbstractFactory: 声明一组用于创建产品的方法，每个方法对应一个产品。
- 具体工厂类 ConcreteFactory： 实现抽象工厂接口，负责创建一组具体产品的对象，如生产古典风格的工厂和生产现代风格的工厂都是具体实例。
## 应用场景
抽象工厂模式特别适用于一系列相关或相互依赖的产品被一起创建的情况，典型的应用场景是使用抽象工厂模式来创建与不同数据库的连接对象。  
## 简单工厂、工厂方法、抽象工厂的区别
- 简单工厂模式：一个工厂方法创建**所有**具体产品
- 工厂方法模式：一个工厂方法创建**一个**具体产品
- 抽象工厂模式：一个工厂方法创建**一类**具体产品


# 建造者模式

# 原型模式

# 适配器模式

# 代理模式

# 装饰模式

# 观察者模式

# 策略模式


